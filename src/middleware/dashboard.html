<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Dashboard</title>
    <!-- Using Tailwind CSS for a modern, responsive UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom transition for sensor bars */
        .sensor-bar {
            transition: height 0.15s ease, background-color 0.15s ease;
        }
        
        /* Styles for plot containers and tabs */
        .plot-container {
            margin-top: 1rem;
        }
        
        .hidden {
            display: none;
        }
        
        .tab-btn.active {
            border-bottom: 2px solid #3b82f6;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans">

    <div class="container mx-auto p-4 max-w-6xl">
        
        <!-- Header -->
        <header class="text-center mb-4">
            <h1 class="text-3xl font-bold text-white">ü§ñ ESP32 Robot Dashboard</h1>
            <p id="connection-status" class="text-lg text-red-500 font-semibold">üî¥ Disconnected</p>
        </header>

        <!-- Main Grid Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Column 1: Controls -->
            <div class="lg:col-span-1 space-y-6">
                
                <!-- Emergency Stop -->
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <button id="btn-emergency" class="btn bg-red-600 hover:bg-red-700 text-white p-4 rounded-lg text-xl font-bold w-full flex items-center justify-center space-x-2">
                        <span>EMERGENCY STOP</span>
                    </button>
                </div>

            </div>

            <!-- Column 2: Telemetry & Sensors -->
            <div class="lg:col-span-2 space-y-6">

                <!-- Telemetry Cards -->
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                    <!-- State -->
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg text-center">
                        <div class="text-sm font-medium text-gray-400 uppercase">State</div>
                        <div id="telemetry-state" class="text-2xl font-bold text-white p-2 mt-2 rounded-md bg-gray-700">IDLE</div>
                    </div>
                    <!-- Obstacle -->
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg text-center">
                        <div class="text-sm font-medium text-gray-400 uppercase">Obstacle</div>
                        <div id="telemetry-obstacle" class="text-2xl font-bold text-green-400 mt-2">‚úÖ CLEAR</div>
                    </div>
                    <!-- Speed -->
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg text-center">
                        <div class="text-sm font-medium text-gray-400 uppercase">Speed</div>
                        <div id="telemetry-speed" class="text-3xl font-bold text-white mt-2">0.00</div>
                        <div class="text-xs text-gray-400">m/s</div>
                    </div>
                    <!-- Battery -->
                    <div class="bg-gray-800 p-4 rounded-lg shadow-lg text-center">
                        <div class="text-sm font-medium text-gray-400 uppercase">Battery</div>
                        <div id="telemetry-battery" class="text-3xl font-bold text-white mt-2">0.00</div>
                        <div class="text-xs text-gray-400">Volts</div>
                    </div>
                </div>

                <!-- Sensor Array -->
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-blue-300">Sensor Array</h2>
                    <div class="bg-gray-900 border border-gray-700 rounded-lg p-4 h-64 flex items-end justify-center space-x-2" id="sensor-array-container">
                        <!-- Sensor bars will be injected here by JavaScript -->
                    </div>
                    <p class="text-center text-sm text-gray-400 mt-2">
                        Bright bars (high) = Black line detected (low sensor value)
                    </p>
                </div>
                
                <!-- Real-time Plots -->
                <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-xl font-semibold mb-4 text-blue-300">Real-time Plots</h2>
                    <!-- Tabs for Ultrasonic and PWM -->
                    <div class="flex border-b border-gray-700 mb-4">
                        <button id="ultrasonic-tab" class="tab-btn px-4 py-2 font-medium text-gray-300 border-b-2 border-transparent hover:border-gray-500 hover:text-white">Ultrasonic</button>
                        <button id="pwm-tab" class="tab-btn px-4 py-2 font-medium text-gray-300 border-b-2 border-transparent hover:border-gray-500 hover:text-white">PWM</button>
                    </div>
                    
                    <!-- Ultrasonic Distance Plot -->
                    <div id="ultrasonic-plot-container" class="plot-container">
                        <div class="bg-gray-900 border border-gray-700 rounded-lg p-4 h-64 relative">
                            <canvas id="ultrasonic-plot" width="600" height="200"></canvas>
                            <div id="ultrasonic-plot-legend" class="absolute bottom-2 left-2 text-xs text-gray-400">Distance (mm)</div>
                        </div>
                    </div>
                    
                    <!-- PWM Plot -->
                    <div id="pwm-plot-container" class="plot-container hidden">
                        <div class="bg-gray-900 border border-gray-700 rounded-lg p-4 h-64 relative">
                            <canvas id="pwm-plot" width="600" height="200"></canvas>
                            <div id="pwm-plot-legend" class="absolute bottom-2 left-2 text-xs text-gray-400">PWM Value</div>
                        </div>
                    </div>
                </div>
            </div>

        </div> <!-- /Main Grid -->
    </div> <!-- /Container -->

    <script>
        class RobotDashboard {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                
                // Map state strings to Tailwind CSS classes for color-coding
                this.stateClasses = {
                    'INIT': 'bg-gray-600',
                    'IDLE': 'bg-blue-600',
                    'LINE_FOLLOW': 'bg-green-600',
                    'AVOID_PREPARE': 'bg-yellow-500 text-gray-900',
                    'AVOID_PATH': 'bg-yellow-600 text-gray-900',
                    'MERGE_SEARCH': 'bg-purple-500',
                    'TURN_LEFT_PREPARE': 'bg-indigo-500',
                    'SLOW_DOWN': 'bg-teal-500',
                    'STOP': 'bg-red-600',
                    'LOST_LINE': 'bg-orange-500',
                    'default': 'bg-gray-700'
                };
                
                this.init();
            }

            init() {
                this.setupWebSocket(); // Use actual WebSocket connection on ESP32
                this.bindEventListeners();
                this.renderSensorArray([0, 0, 0, 0, 0, 0, 0]); // Initial render
                
                // Connection status will be updated by WebSocket events
                this.setConnectionStatus(false); // Start as disconnected
            }

            setupWebSocket() {
                // This is the original function, which would be used on the ESP32
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.hostname}/ws`;
                
                try {
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('Connected to WebSocket');
                        this.setConnectionStatus(true);
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.updateUI(data);
                        } catch (e) {
                            console.error('Error parsing WebSocket message:', e);
                        }
                    };

                    this.ws.onclose = () => {
                        console.log('WebSocket connection closed');
                        this.setConnectionStatus(false);
                        // Attempt to reconnect after 3 seconds
                        setTimeout(() => this.setupWebSocket(), 3000);
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.setConnectionStatus(false);
                    };
                } catch (e) {
                    console.error('Failed to create WebSocket connection:', e);
                    this.setConnectionStatus(false);
                }
            }

            bindEventListeners() {
                // Emergency Stop
                document.getElementById('btn-emergency').addEventListener('click', () => this.sendCommand('stop'));
            }

            setConnectionStatus(connected) {
                this.isConnected = connected;
                const statusEl = document.getElementById('connection-status');
                if (connected) {
                    statusEl.textContent = 'üü¢ Connected to Robot';
                    statusEl.className = 'text-lg text-green-400 font-semibold';
                } else {
                    // Show a special message for preview mode
                    statusEl.textContent = 'üî¥ Disconnected (Preview Mode)';
                    statusEl.className = 'text-lg text-red-400 font-semibold';
                }
            }

            updateUI(data) {
                if (data.speed != null) {
                    document.getElementById('telemetry-speed').textContent = data.speed.toFixed(2);
                }
                if (data.battery != null) {
                    document.getElementById('telemetry-battery').textContent = data.battery.toFixed(2);
                }
                if (data.state) {
                    const stateEl = document.getElementById('telemetry-state');
                    stateEl.textContent = data.state;
                    // Apply color-coding based on state
                    const stateClass = this.stateClasses[data.state] || this.stateClasses['default'];
                    stateEl.className = `text-xl font-bold text-white p-2 mt-2 rounded-md ${stateClass}`;
                }
                if (data.obstacle != null) {
                    const obstacleEl = document.getElementById('telemetry-obstacle');
                    if (data.obstacle) {
                        obstacleEl.textContent = '‚ö†Ô∏è DETECTED';
                        obstacleEl.className = 'text-2xl font-bold text-red-400 mt-2';
                    } else {
                        obstacleEl.textContent = '‚úÖ CLEAR';
                        obstacleEl.className = 'text-2xl font-bold text-green-400 mt-2';
                    }
                }
                if (data.sensors && Array.isArray(data.sensors)) {
                    this.renderSensorArray(data.sensors);
                }
                if (data.ultrasonic !== undefined) {
                    this.updatePlotData(data.ultrasonic, undefined);
                }
                if (data.pwm !== undefined) {
                    this.updatePlotData(undefined, data.pwm);
                }
            }

            renderSensorArray(sensors) {
                const sensorContainer = document.getElementById('sensor-array-container');
                sensorContainer.innerHTML = ''; // Clear previous bars
                
                // Assuming sensor values are 0-1023, where < 500 is "black"
                const SENSOR_MAX = 1023;
                const LINE_THRESHOLD = 500; // Adjust this threshold to match your robot
                
                sensors.forEach((value, index) => {
                    // Invert the value: low value (black) = high bar
                    const heightPercent = Math.min(100, (SENSOR_MAX - value) / SENSOR_MAX * 100);
                    const isOverLine = value < LINE_THRESHOLD;

                    const bar = document.createElement('div');
                    bar.className = 'sensor-bar w-full rounded-t-md relative';
                    
                    // Set height
                    bar.style.height = `${heightPercent}%`;
                    
                    // Set color based on whether it detects the line
                    bar.style.backgroundColor = isOverLine ? '#34d399' : '#374151'; // green-400 or gray-700
                    
                    // Add a label inside the bar to show the raw value
                    const valueLabel = document.createElement('span');
                    valueLabel.className = 'absolute bottom-1 left-0 right-0 text-center text-xs text-white/70';
                    valueLabel.textContent = value;
                    
                    bar.appendChild(valueLabel);
                    sensorContainer.appendChild(bar);
                });
            }

            sendCommand(cmd) {
                // Mock send command for preview
                console.log('Mock Send command:', cmd);
                // Simulate state changes on button press
                if (cmd === 'start') {
                    this.updateUI({ state: 'LINE_FOLLOW' });
                }
                if (cmd === 'stop') {
                    this.updateUI({ state: 'IDLE', speed: 0.0 });
                }
                if (cmd === 'down') {
                    // Assuming "down" means stop or reverse, just stop for simulation
                    this.updateUI({ state: 'IDLE', speed: 0.0 });
                    console.log('Mock: Robot moving backward or stopping');
                }
            }

            // Plotting functionality for ultrasonic and PWM data
            initializePlots() {
                // Initialize data arrays to hold the last 100 data points
                this.ultrasonicData = new Array(100).fill(null);
                this.pwmData = new Array(100).fill(null);
                
                // Get canvas elements
                this.ultrasonicCanvas = document.getElementById('ultrasonic-plot');
                this.pwmCanvas = document.getElementById('pwm-plot');
                
                // Get 2D contexts for drawing
                this.ultrasonicCtx = this.ultrasonicCanvas.getContext('2d');
                this.pwmCtx = this.pwmCanvas.getContext('2d');
                
                // Set canvas dimensions to match their containers
                this.resizeCanvases();
                
                // Initialize plots
                this.drawUltrasonicPlot();
                this.drawPwmPlot();
                
                // Add event listeners for tab switching
                document.getElementById('ultrasonic-tab').addEventListener('click', () => {
                    this.switchTab('ultrasonic');
                });
                document.getElementById('pwm-tab').addEventListener('click', () => {
                    this.switchTab('pwm');
                });
                
                // Initially activate ultrasonic tab
                this.switchTab('ultrasonic');
            }
            
            resizeCanvases() {
                // Get the container dimensions
                const ultrasonicContainer = this.ultrasonicCanvas.parentElement;
                const pwmContainer = this.pwmCanvas.parentElement;
                
                // Set canvas dimensions to match container
                this.ultrasonicCanvas.width = ultrasonicContainer.clientWidth;
                this.ultrasonicCanvas.height = ultrasonicContainer.clientHeight;
                
                this.pwmCanvas.width = pwmContainer.clientWidth;
                this.pwmCanvas.height = pwmContainer.clientHeight;
            }
            
            updatePlotData(ultrasonicDist, pwmValue) {
                // Add new data to arrays and maintain 100 element capacity
                if (ultrasonicDist !== undefined) {
                    this.ultrasonicData.push(ultrasonicDist);
                    if (this.ultrasonicData.length > 100) {
                        this.ultrasonicData.shift();
                    }
                    this.drawUltrasonicPlot();
                }
                
                if (pwmValue !== undefined) {
                    this.pwmData.push(pwmValue);
                    if (this.pwmData.length > 100) {
                        this.pwmData.shift();
                    }
                    this.drawPwmPlot();
                }
            }
            
            drawUltrasonicPlot() {
                if (!this.ultrasonicCtx) return;
                
                const ctx = this.ultrasonicCtx;
                const width = this.ultrasonicCanvas.width;
                const height = this.ultrasonicCanvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid
                this.drawGrid(ctx, width, height, 'mm');
                
                // Draw data line
                this.drawDataLine(ctx, width, height, this.ultrasonicData, 0, 500, '#3b82f6'); // Blue line for ultrasonic
                
                // Draw max/min value indicators
                this.drawMinMaxValues(ctx, this.ultrasonicData, 'mm');
            }
            
            drawPwmPlot() {
                if (!this.pwmCtx) return;
                
                const ctx = this.pwmCtx;
                const width = this.pwmCanvas.width;
                const height = this.pwmCanvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid
                this.drawGrid(ctx, width, height, 'pwm');
                
                // Draw data line
                this.drawDataLine(ctx, width, height, this.pwmData, -255, 255, '#10b981'); // Green line for PWM
                
                // Draw max/min value indicators
                this.drawMinMaxValues(ctx, this.pwmData, 'pwm');
            }
            
            drawGrid(ctx, width, height, type) {
                ctx.strokeStyle = '#374151'; // Dark gray grid
                ctx.lineWidth = 1;
                
                // Draw horizontal grid lines (4 lines)
                for (let i = 0; i <= 4; i++) {
                    const y = height - (i * height / 4);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Draw vertical grid lines (5 lines)
                for (let i = 0; i <= 5; i++) {
                    const x = i * width / 5;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // Add Y-axis labels
                ctx.fillStyle = '#9ca3af'; // Gray text
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                
                let maxValue, minValue;
                if (type === 'mm') {
                    maxValue = 500;
                    minValue = 0;
                } else { // pwm
                    maxValue = 255;
                    minValue = -255;
                }
                
                const range = maxValue - minValue;
                for (let i = 0; i <= 4; i++) {
                    const value = maxValue - (i * range / 4);
                    const y = (i * height / 4) + 5;
                    ctx.fillText(Math.round(value), width - 5, y);
                }
            }
            
            drawDataLine(ctx, width, height, data, minValue, maxValue, color) {
                if (!data || data.length === 0) return;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const range = maxValue - minValue;
                const stepX = width / (data.length - 1);
                
                let firstValidPoint = true;
                for (let i = 0; i < data.length; i++) {
                    if (data[i] === null) continue;
                    
                    const x = i * stepX;
                    // Calculate Y position (inverted because canvas Y increases downward)
                    const normalizedValue = (data[i] - minValue) / range;
                    const y = height - (normalizedValue * height);
                    
                    if (firstValidPoint) {
                        ctx.moveTo(x, y);
                        firstValidPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
            
            drawMinMaxValues(ctx, data, unit) {
                if (!data || data.length === 0) return;
                
                // Filter out null values
                const validData = data.filter(val => val !== null);
                if (validData.length === 0) return;
                
                // Find min and max values
                const minVal = Math.min(...validData);
                const maxVal = Math.max(...validData);
                
                // Display min and max values
                ctx.fillStyle = '#9ca3af'; // Gray text
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Min: ${minVal.toFixed(1)} ${unit}`, 10, 15);
                ctx.fillText(`Max: ${maxVal.toFixed(1)} ${unit}`, 10, 30);
            }
            
            switchTab(tabName) {
                // Hide all plot containers
                document.getElementById('ultrasonic-plot-container').classList.add('hidden');
                document.getElementById('pwm-plot-container').classList.add('hidden');
                
                // Remove active class from all tabs
                document.getElementById('ultrasonic-tab').classList.remove('active');
                document.getElementById('pwm-tab').classList.remove('active');
                
                // Show selected plot container and activate tab
                if (tabName === 'ultrasonic') {
                    document.getElementById('ultrasonic-plot-container').classList.remove('hidden');
                    document.getElementById('ultrasonic-tab').classList.add('active');
                } else if (tabName === 'pwm') {
                    document.getElementById('pwm-plot-container').classList.remove('hidden');
                    document.getElementById('pwm-tab').classList.add('active');
                }
            }
        }

        // Initialize the dashboard when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const dashboard = new RobotDashboard();
            // Initialize plots after dashboard is created
            dashboard.initializePlots();
        });
    </script>
</body>
</html>